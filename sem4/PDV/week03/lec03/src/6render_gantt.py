# generated by Claude 3.5 Sonnet
# pipe output from 6for_gantt to this script to get the Gantt chart for the loop execution

import sys
import matplotlib.pyplot as plt
import matplotlib.cm as cm
import numpy as np
import re

def parse_thread_log(file):
    thread_data = []

    for line in file:
        # Split the line and strip whitespace
        parts = line.strip().split()

        # Ensure the line has exactly 4 parts
        if len(parts) == 4:
            try:
                thread_data.append({
                    'iteration': int(parts[0]),
                    'thread': parts[1],
                    'start_time': float(parts[2]),
                    'end_time': float(parts[3])
                })
            except ValueError:
                print(f"Skipping invalid line: {line.strip()}")

    return thread_data

def extract_thread_id(thread_name):
    """
    Extract numeric ID from thread name.

    Parameters:
    thread_name (str): Name of the thread

    Returns:
    int: Extracted thread ID
    """
    # Extract numeric ID from thread name (works for formats like Thread-0, Thread-1, etc.)
    match = re.search(r'-?(\d+)', thread_name)
    return int(match.group(1)) if match else float('inf')

def create_thread_gantt_chart(thread_data):
    """
    Create a Gantt chart to visualize thread execution schedule.

    Parameters:
    thread_data (list): List of dictionaries containing thread execution details
    """
    # Sort thread data by start time
    sorted_data = sorted(thread_data, key=lambda x: x['start_time'])

    # Determine unique threads and sort them by their numeric ID
    unique_threads = sorted(set(entry['thread'] for entry in sorted_data),
                            key=extract_thread_id)

    # Prepare data for plotting
    plot_data = []
    for thread in unique_threads:
        thread_entries = [entry for entry in sorted_data if entry['thread'] == thread]
        plot_data.extend(thread_entries)

    # Prepare data for plotting
    threads = [entry['thread'] for entry in plot_data]
    starts = [entry['start_time'] for entry in plot_data]
    durations = [entry['end_time'] - entry['start_time'] for entry in plot_data]
    iterations = [entry['iteration'] for entry in plot_data]

    # Create the Gantt chart
    fig, ax = plt.subplots(figsize=(14, 8))

    # Determine the color gradient based on iteration numbers
    min_iteration = min(iterations)
    max_iteration = max(iterations)

    # Use a perceptually uniform colormap for better visualization
    colormap = cm.viridis

    # Plot the bars
    for thread, start, duration, iteration in zip(threads, starts, durations, iterations):
        # Normalize iteration to [0, 1] for color mapping
        normalized_iteration = (iteration - min_iteration) / (max_iteration - min_iteration)

        # Get color from the colormap
        color = colormap(normalized_iteration)

        # Plot the bar
        rect = ax.barh(thread, duration, left=start,
                color=color,
                edgecolor='black',
                height=0.5,
                alpha=0.7)

        # Add iteration number to the bar
        ax.text(start + duration/2, thread, str(iteration),
                ha='center',
                va='center',
                color='black',
                fontweight='bold',
                fontsize=15)

    # Customize the chart
    ax.set_xlabel('Time (seconds)', fontsize=10)
    ax.set_ylabel('Threads', fontsize=10)

    # Add grid lines
    ax.grid(axis='x', linestyle='--', alpha=0.7)

    # Automatically adjust layout
    plt.tight_layout()

    return fig, ax

def main(file):
    # Parse the log file
    thread_data = parse_thread_log(file)

    # Validate data
    if not thread_data:
        print("No valid thread execution data found.")
        return

    # Create and show the Gantt chart
    fig, ax = create_thread_gantt_chart(thread_data)
    plt.show()


# Example usage
if __name__ == '__main__':
    main(sys.stdin)
